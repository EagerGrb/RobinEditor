# 06-属性系统与数据绑定-详细设计

适用范围：PCB 实体（Board、Layer、Footprint、Pad、Track、Via 等）的属性系统与 UI 数据绑定。

## 1. 设计目标
构建一套**元数据驱动 (Metadata-Driven)** 的属性系统，实现 UI 属性面板与内核图元数据的自动绑定与双向同步。
支持动态生成表单、属性验证、以及针对不同图元类型的属性扩展。

## 2. 核心架构：Schema & Adapter

### 2.1 属性定义 (Property Schema)
每个图元类型（如 Footprint, Pad, Track, Via, BoardOutline）都需要定义其属性的元数据，供 UI 渲染器使用。

```typescript
// packages/graphics-kernel/src/property/types.ts

export type PropertyType = 'string' | 'number' | 'boolean' | 'color' | 'enum' | 'vector2';

export interface IPropertySchema {
  key: string;          // 属性名 (e.g., 'thickness')
  label: string;        // 显示名 (e.g., '线宽')
  type: PropertyType;
  readonly?: boolean;   // 是否只读
  defaultValue?: any;
  
  // 约束
  min?: number;
  max?: number;
  step?: number;
  options?: { label: string; value: any }[]; // For enum
  
  // 分组
  group?: string;       // e.g., 'Geometry', 'Appearance'
}

export interface IEntitySchema {
  type: string;         // e.g., 'Wall'
  properties: IPropertySchema[];
}
```

### 2.2 实体属性访问 (IPropertyProvider)
所有 Entity 必须实现此接口，以便系统统一读写属性。

```typescript
// packages/graphics-kernel/src/model/Entity.ts

export interface IPropertyProvider {
  // 获取实体的 Schema 定义
  getSchema(): IEntitySchema;
  
  // 获取属性当前值
  getProperty(key: string): any;
  
  // 设置属性值 (返回是否成功/验证结果)
  setProperty(key: string, value: any): boolean;
}
```

---

## 3. UI 数据绑定流程

### 3.1 选中驱动 (Selection Driven)
属性面板的内容由当前的**选中集 (Selection)** 决定。

1.  **Selection Change Event**: 内核抛出 `SELECTION_CHANGED` 事件，携带 `selectedIds`。
2.  **UI Store Update**: UI 层（Zustand/Redux）接收事件，获取对应的 Entity 对象。
3.  **Schema Resolution**:
    *   **单选**: 直接读取该 Entity 的 Schema。
    *   **多选 (同类型)**: 读取 Schema，显示共有属性值；若值不同，显示 `<Multiple Values>`。
    *   **多选 (不同类型)**: 仅显示交集属性（如 Layer, Color）或显示为空。

### 3.2 双向同步机制

#### 3.2.1 Model -> UI (Read)
当 Entity 数据变更时（如撤销/重做/协同更新）：
1.  内核抛出 `ENTITY_UPDATED` 事件。
2.  UI 组件订阅该事件。
3.  如果更新的 Entity ID 在当前选中集中，UI 重新渲染对应的表单控件。

#### 3.2.2 UI -> Model (Write)
当用户在属性面板修改值时：
1.  UI 组件调用 `onChange`。
2.  **Command Generation**: 构造 `PropertyChangeCommand(entity, key, oldValue, newValue)`。
3.  **Execution**: 调用 `historyManager.execute(cmd)`。
4.  **Feedback**: Command 执行后触发 `ENTITY_UPDATED`，闭环更新 UI（确保值已被合法化）。

---

## 4. 实现细节

### 4.1 属性适配器 (PropertyAdapter)
为了避免 UI 直接依赖复杂的 Entity 对象，可以使用 Adapter 模式转换数据。

```typescript
export class PropertyAdapter {
  static getFormModel(entity: Entity): FormModel {
    const schema = entity.getSchema();
    const values = {};
    schema.properties.forEach(prop => {
      values[prop.key] = entity.getProperty(prop.key);
    });
    return { schema, values };
  }
}
```

### 4.2 动态表单组件 (React示例)

```tsx
// apps/editor-web/src/components/PropertyPanel/DynamicForm.tsx

const DynamicForm = ({ schema, values, onChange }) => {
  return (
    <div>
      {schema.properties.map(prop => (
        <Field 
          key={prop.key}
          label={prop.label}
          component={getComponentByType(prop.type)}
          value={values[prop.key]}
          onChange={(val) => onChange(prop.key, val)}
          // 传递约束
          min={prop.min}
          max={prop.max}
        />
      ))}
    </div>
  );
};
```

### 4.3 复杂类型处理
对于 `vector2` 或 `color` 等复杂类型，需要专门的序列化/反序列化逻辑。
*   **Color**: 存储为 Hex string 或 Integer，UI 使用 ColorPicker。
*   **Vector2**: 存储为 `{x, y}` 对象，UI 渲染为两个 NumberInput。

---

## 5. 扩展性设计 (Custom Properties)
除了硬编码的 Schema，还应支持**自定义属性**（用户数据）。

*   在 `Entity` 基类中增加 `customProperties: Record<string, any>`。
*   Schema 中增加一个特殊的 `DynamicGroup`，用于渲染这些 KV 对。
*   这对于后续对接制造数据或其他 EDA 工艺信息非常重要。

## 6. 角色与责任分工（智能体）

- 前端架构（frontend-architect）
  - 负责属性面板 UI、动态表单组件以及与属性系统的绑定实现；
  - 定义 PCB 实体属性在 UI 中的分组与展示方式（几何、工艺、电气等）。
- 图形开发专家（graphics-engineer）
  - 设计并实现 IPropertySchema/IEntitySchema/IPropertyProvider 等核心接口；
  - 为 Board、Layer、Footprint、Pad、Track、Via 等实体提供完整的属性 Schema 和访问实现。
- 产品架构师（product-architect）
  - 从用户视角定义各类 PCB 实体在阶段一必须暴露的属性集合与默认值；
  - 规划后续阶段的属性扩展（如更多工艺、电气约束相关字段）。
- 测试专家（qa-automation-expert）
  - 设计属性读写与命令生成的自动化测试；
  - 覆盖单选/多选、不同实体类型混选、属性验证失败等边界场景。
