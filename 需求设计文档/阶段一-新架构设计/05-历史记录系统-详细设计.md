# 05-历史记录系统-详细设计

## 1. 设计目标
构建一个通用的、支持事务的撤销/重做（Undo/Redo）系统，确保编辑器中的所有状态变更（增删改）都是可追溯、可回滚的。
适用于 **几何图形编辑器** 场景，需处理大量微小变更（如拖拽过程）的性能与合并问题。

## 2. 核心架构：Command Pattern (命令模式)

### 2.1 接口定义
所有对模型（Model）的修改都必须封装为 `ICommand` 对象。

```typescript
// packages/graphics-kernel/src/history/ICommand.ts

export interface ICommand {
  // 命令唯一标识 (用于合并策略)
  readonly id: string;
  
  // 命令名称 (用于 UI 显示，如 "Move Wall")
  readonly label: string;

  // 执行命令
  execute(): void | Promise<void>;

  // 撤销命令
  undo(): void | Promise<void>;

  // 可选：重做命令 (通常与 execute 相同，但有时需特殊处理)
  redo?(): void | Promise<void>;

  // 可选：合并策略 (用于连续操作，如拖拽)
  merge?(nextCommand: ICommand): boolean;
}
```

### 2.2 基础命令实现示例

#### 2.2.1 属性变更命令 (`PropertyChangeCommand`)
```typescript
export class PropertyChangeCommand<T extends Entity> implements ICommand {
  readonly id = uuid();
  readonly label = 'Change Property';

  constructor(
    private entity: T,
    private propKey: keyof T,
    private oldValue: any,
    private newValue: any
  ) {}

  execute() {
    this.entity[this.propKey] = this.newValue;
    // 触发变更事件
    EventBus.publish(Events.ENTITY_UPDATED, this.entity);
  }

  undo() {
    this.entity[this.propKey] = this.oldValue;
    EventBus.publish(Events.ENTITY_UPDATED, this.entity);
  }

  merge(next: ICommand): boolean {
    // 如果是同一个实体的同一个属性变更，则合并
    if (next instanceof PropertyChangeCommand &&
        next.entity === this.entity &&
        next.propKey === this.propKey) {
      this.newValue = next.newValue; // 更新终值
      return true;
    }
    return false;
  }
}
```

#### 2.2.2 批量操作命令 (`BatchCommand`)
用于组合多个原子命令（如：删除一个顶点同时删除相连的墙）。

```typescript
export class BatchCommand implements ICommand {
  readonly id = uuid();
  constructor(
    public readonly label: string,
    private commands: ICommand[]
  ) {}

  execute() {
    // 顺序执行
    this.commands.forEach(cmd => cmd.execute());
  }

  undo() {
    // 逆序撤销
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
}
```

---

## 3. 历史管理器 (HistoryManager)

### 3.1 职责
*   维护 `undoStack` 和 `redoStack`。
*   管理事务 (Transaction)。
*   对外暴露 `canUndo`, `canRedo` 状态。

### 3.2 接口与实现
```typescript
// packages/graphics-kernel/src/history/HistoryManager.ts

export class HistoryManager {
  private undoStack: ICommand[] = [];
  private redoStack: ICommand[] = [];
  private maxStackSize: number = 50;
  
  // 事务相关
  private transactionBuffer: ICommand[] = [];
  private isTransactionActive: boolean = false;
  private transactionLabel: string = '';

  /**
   * 执行并记录命令
   */
  execute(command: ICommand) {
    // 如果在事务中，暂存到 buffer
    if (this.isTransactionActive) {
      command.execute(); // 立即执行，以便后续操作能基于新状态
      this.transactionBuffer.push(command);
      return;
    }

    // 执行命令
    command.execute();

    // 尝试合并
    const lastCmd = this.undoStack[this.undoStack.length - 1];
    if (lastCmd && lastCmd.merge && lastCmd.merge(command)) {
      // 合并成功，不压栈
      return;
    }

    // 压栈
    this.undoStack.push(command);
    
    // 清空 Redo 栈 (新操作会使未来的历史失效)
    this.redoStack = [];

    // 限制栈大小
    if (this.undoStack.length > this.maxStackSize) {
      this.undoStack.shift();
    }

    this.notifyChanged();
  }

  undo() {
    const cmd = this.undoStack.pop();
    if (cmd) {
      cmd.undo();
      this.redoStack.push(cmd);
      this.notifyChanged();
    }
  }

  redo() {
    const cmd = this.redoStack.pop();
    if (cmd) {
      cmd.execute();
      this.undoStack.push(cmd);
      this.notifyChanged();
    }
  }

  // --- 事务支持 ---

  startTransaction(label: string) {
    if (this.isTransactionActive) {
      console.warn('Transaction already active, nesting not supported yet.');
      return;
    }
    this.isTransactionActive = true;
    this.transactionLabel = label;
    this.transactionBuffer = [];
  }

  commitTransaction() {
    if (!this.isTransactionActive) return;
    
    if (this.transactionBuffer.length > 0) {
      const batchCmd = new BatchCommand(this.transactionLabel, [...this.transactionBuffer]);
      // 手动压栈，跳过 execute (因为已经在 buffer 阶段执行过了)
      this.undoStack.push(batchCmd);
      this.redoStack = [];
      this.notifyChanged();
    }
    
    this.isTransactionActive = false;
    this.transactionBuffer = [];
  }

  abortTransaction() {
    if (!this.isTransactionActive) return;
    
    // 回滚 buffer 中的操作
    for (let i = this.transactionBuffer.length - 1; i >= 0; i--) {
      this.transactionBuffer[i].undo();
    }
    
    this.isTransactionActive = false;
    this.transactionBuffer = [];
  }

  private notifyChanged() {
    EventBus.publish('HISTORY_CHANGED', {
      canUndo: this.undoStack.length > 0,
      canRedo: this.redoStack.length > 0,
      undoLabel: this.undoStack[this.undoStack.length - 1]?.label
    });
  }
}
```

---

## 4. 关键场景应用

### 4.1 连续拖拽 (Continuous Dragging)
当用户拖拽图元时，会触发大量的 `mousemove` 事件。
**策略**:
1.  **Mouse Down**: 调用 `history.startTransaction('Drag Entity')`。
2.  **Mouse Move**: 计算 delta，构造 `MoveCommand` 并执行。
    *   *优化*: 可以在 MoveCommand 内部实现 merge 逻辑，或者在 Transaction 内部只保留最后一次的位置更新（如果是覆盖式更新）。
    *   *更优解*: 在 `Mouse Move` 期间不直接生成 Command，而是直接修改 Entity 的 `tempPosition` 并渲染。只有在 `Mouse Up` 时生成一个最终的 `MoveCommand` 并提交。
3.  **Mouse Up**: 调用 `history.commitTransaction()`。

### 4.2 复杂级联删除 (Cascading Delete)
当删除一个 Vertex 时，需要同时删除相连的 Walls。
**策略**:
1.  用户点击删除。
2.  Service 层计算依赖关系：找到 Vertex 关联的 WallIds。
3.  `history.startTransaction('Delete Vertex')`。
4.  生成 `DeleteWallCommand` (针对 Wall A)。
5.  生成 `DeleteWallCommand` (针对 Wall B)。
6.  生成 `DeleteVertexCommand`。
7.  `history.commitTransaction()`。
这样撤销时，会一次性恢复顶点和墙体。

---

## 5. 序列化与持久化
虽然 `ICommand` 对象本身通常不直接序列化（因为包含运行时对象引用），但对于**宏命令**或**操作回放**场景，可以设计 `ISerializableCommand`。

```typescript
interface ISerializableCommand {
  type: string; // e.g., 'CMD_MOVE'
  payload: any; // JSON data
}
```
但对于 Stage 1，建议优先保证内存中的 Undo/Redo，持久化通过保存 Scene JSON 快照来实现，而不是保存命令流。
