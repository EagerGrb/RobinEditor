# 阶段一任务包：qa-automation-expert

使用方式：本任务包用于指导你建立属于自己的测试空间，并为各专家的最小模块设计与执行测试。发现问题时，请先在你的文件夹中记录，再由产品架构师确认后进入修复流程。

## 一、自有测试空间与记录规范

1. 创建 QA 专属文件夹
   - 在仓库根目录创建一个 QA 文件夹，例如：`qa-notes/` 或 `tests/qa-reports/`。
   - 在该文件夹下建立子目录：
     - `frontend/`：前端架构与 UI 相关问题与测试记录。
     - `graphics/`：图形内核与几何算法相关问题与测试记录。
     - `rendering/`：渲染引擎相关问题与测试记录。
     - `integration/`：模块间集成与端到端问题记录。

2. 建立记录模板
   - 在 QA 文件夹下创建说明文档（如 `README.md` 或 `index.md`），内容包括：
     - 用例 ID 命名规范（例如：FRONTEND-001, GRAPHICS-001 等）。
     - 记录字段：
       - 用例/问题 ID
       - 模块
       - 前置条件
       - 复现步骤
       - 预期结果
       - 实际结果
       - 状态（待确认/已确认/已修复/回归通过）
       - 备注（怀疑原因、截图说明等）。

## 二、前端架构与 UI 测试

3. 单元测试：布局与 UI Shell
   - 为 `ui-shell` 中的布局组件编写单元测试：
     - 验证顶部菜单、左右面板、底部状态栏、中央画布区域是否正确渲染。
     - 在不同视口宽度下（可模拟）布局是否合理（不折行、不遮挡）。
   - 工具建议：Jest + React Testing Library。

4. 事件总线单元测试
   - 针对 `packages/event-bus`：
     - 测试订阅与发布机制：单订阅、多订阅、取消订阅是否生效。
     - 测试中间件/拦截器行为（如日志、节流逻辑）。
   - 对异常情况编写用例（如订阅过程中抛错、不存在的 topic）。

5. UI 行为测试（端到端）
   - 使用 Playwright 或 Cypress：
     - 测试工具栏按钮点击是否触发正确的事件（可通过 mock event-bus 或检查中介者输出）。
     - 测试菜单点击是否发出对应命令（新建/保存/视图重置）。

## 三、图形内核与几何算法测试

6. 几何算法单元测试
   - 对 GeometryUtils 中的核心方法进行测试：
     - 点到线段距离：覆盖垂直、斜线、端点、在线上、线外等情况。
     - 坐标转换：在不同缩放/平移组合下的 world <-> screen 转换一致性。
     - 网格/端点/墙线吸附：验证在设定阈值下的吸附结果是否正确。

7. 工具链与交互流程测试
   - 模拟输入事件序列测试 ToolChain：
     - 连续点击创建墙体：检查最终墙体数量与坐标是否符合预期。
     - 框选操作：确认被选中的图元集合正确。
   - 测试 Tool 之间的职责链行为：
     - 某个 Tool 处理事件后是否正确阻止/放行给后续工具。

8. MVC 一致性测试
   - 在不依赖 DOM 的环境下：
     - 修改某个 Model 后，检查生成的 View 描述是否同步更新。
     - 改变选中状态时，是否触发内核发出正确的「选中变化」通知（可通过 mock 中介者捕获）。

## 四、渲染引擎测试

9. 渲染输出一致性
   - 构造固定的 DrawCommand 列表（少量墙体、门窗、尺寸等）：
     - 渲染到离屏 Canvas 中，得到像素数据或快照。
     - 与基准数据进行对比（允许少量误差），检测渲染回归问题。

10. DPI 与缩放测试
    - 在不同 DPR 下（模拟 window.devicePixelRatio）：
      - 检查线条是否清晰无毛边。
      - 检查文本在不同缩放等级下是否可读。

11. 性能测试
    - 构造大规模场景：
      - 例如 1000+ 墙体、5000+ 标注线，测量渲染时间与帧率。
    - 记录性能数据并在 QA 文件夹中建立性能报告（如 `rendering/performance-stage1.md`）。

## 五、集成与端到端测试

12. 基本绘制流程测试
    - 通过 UI 模拟用户完整操作：
      - 进入墙体绘制工具 → 连续绘制多段墙体 → 添加门窗 → 添加尺寸标注。
    - 检查：
      - UI 是否正确反馈（高亮、属性面板更新）。
      - 场景数据是否合理（无非法拓扑、自交、门窗越界）。
      - 渲染结果是否与操作意图一致。

13. 异常与边界情况测试
    - 测试非法操作：
      - 尝试在没有墙体的地方放置门窗，应得到合理反馈而非崩溃。
      - 绘制极短/极长墙体，检查算法与渲染表现。
    - 测试撤销/重做链的正确性（当相关功能实现后）。

## 六、缺陷记录与与产品架构师协作

14. 缺陷记录流程
    - 每发现一个问题：
      - 在对应子目录下创建一条记录，如：`graphics/BUG-001-wall-snapping-inaccurate.md`。
      - 按记录模板填写用例/问题描述与复现步骤。
      - 在「怀疑原因」中写出你的技术判断（例如：可能是某算法的边界条件问题）。

15. 与产品架构师确认
    - 对每个问题，先由你打标签：
      - 疑似缺陷/需求不明确/可接受行为。
    - 将问题摘要同步给 product-architect 进行判定：
      - 是真正的缺陷 → 进入修复队列。
      - 是需求问题 → 返回产品侧调整需求文档。
      - 是暂时接受的折衷 → 标记为「已知问题」。

16. 回归与状态更新
    - 对已修复的问题：
      - 在对应记录文件中更新状态为「已修复」，补充修复版本号和回归结果。
      - 如有必要，更新或新增自动化测试用例，防止再次回归。

